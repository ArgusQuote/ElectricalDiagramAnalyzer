---
description: Enforce DRY principles - avoid code duplication, create reusable components and utilities
globs: **/*.py
alwaysApply: true
---

# Code Reusability Standards

This rule enforces the DRY (Don't Repeat Yourself) principle and promotes code reusability throughout the codebase.

## Core Principles

| Principle | Description |
|-----------|-------------|
| **Single Source of Truth** | Each piece of knowledge should have one authoritative representation |
| **Extract Common Logic** | If you write similar code twice, consider extracting it |
| **Parameterize Variations** | Use parameters/arguments instead of duplicating with minor changes |
| **Leverage Existing Code** | Always search for existing implementations before creating new ones |

## Before Writing New Code

**Always check these locations first:**

1. **Existing utilities** - Search the codebase for similar functionality
2. **Base classes** - Check if a parent class already provides the behavior
3. **Helper functions** - Look in related modules for shared helpers
4. **Configuration files** - Check if behavior can be driven by config instead of code

```python
# ❌ Bad: Creating new function without checking existing code
def convert_pdf_to_image(pdf_path, page_num):
    doc = fitz.open(pdf_path)
    page = doc.load_page(page_num)
    pix = page.get_pixmap(dpi=200)
    # ... implementation

# ✅ Good: Reuse existing implementation
from VisualDetectionToolLibrary.PanelSearchToolV21 import PanelBoardSearch
# Or extract shared utility if used across multiple modules
```

## Duplication Detection Triggers

**Create a shared utility when you see:**

- Same logic in 2+ places (consider extracting)
- Same logic in 3+ places (must extract)
- Copy-pasting and modifying slightly
- Multiple classes with identical methods
- Similar try/except patterns repeated

## Refactoring Patterns

### Extract Method

```python
# ❌ Bad: Repeated inline logic
def process_panel_a(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)
    # ... rest of processing

def process_panel_b(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 150)
    # ... rest of processing

# ✅ Good: Extract common preprocessing
def preprocess_image(image, blur_kernel=(5, 5), canny_low=50, canny_high=150):
    """Common image preprocessing pipeline."""
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, blur_kernel, 0)
    edges = cv2.Canny(blurred, canny_low, canny_high)
    return edges

def process_panel_a(image):
    edges = preprocess_image(image)
    # ... rest of processing

def process_panel_b(image):
    edges = preprocess_image(image)
    # ... rest of processing
```

### Extract Class/Base Class

```python
# ❌ Bad: Multiple parsers with duplicate initialization
class BreakerParserV1:
    def __init__(self):
        self.reader = easyocr.Reader(['en'])
        self.debug_mode = False
        self.output_dir = None

class BreakerParserV2:
    def __init__(self):
        self.reader = easyocr.Reader(['en'])
        self.debug_mode = False
        self.output_dir = None

# ✅ Good: Extract base class
class BaseBreakerParser:
    def __init__(self):
        self.reader = easyocr.Reader(['en'])
        self.debug_mode = False
        self.output_dir = None
    
    def setup_debug(self, output_dir):
        self.debug_mode = True
        self.output_dir = output_dir

class BreakerParserV1(BaseBreakerParser):
    # Only version-specific logic here

class BreakerParserV2(BaseBreakerParser):
    # Only version-specific logic here
```

### Parameterize Instead of Duplicate

```python
# ❌ Bad: Separate functions for minor variations
def find_header_strict(image):
    return find_pattern(image, threshold=0.95, min_matches=5)

def find_header_loose(image):
    return find_pattern(image, threshold=0.7, min_matches=2)

# ✅ Good: Single parameterized function
def find_header(image, threshold=0.85, min_matches=3):
    """
    Find header with configurable strictness.
    
    Args:
        image: Input image
        threshold: Match confidence (0.7=loose, 0.95=strict)
        min_matches: Minimum pattern matches required
    """
    return find_pattern(image, threshold=threshold, min_matches=min_matches)

# Usage
header_strict = find_header(image, threshold=0.95, min_matches=5)
header_loose = find_header(image, threshold=0.7, min_matches=2)
```

## Configuration-Driven Behavior

```python
# ❌ Bad: Hardcoded variations
if panel_type == "residential":
    columns = ["Circuit", "Load", "Breaker"]
    max_circuits = 42
elif panel_type == "commercial":
    columns = ["Circuit", "Load", "Breaker", "Phase"]
    max_circuits = 84

# ✅ Good: Configuration-driven
PANEL_CONFIG = {
    "residential": {
        "columns": ["Circuit", "Load", "Breaker"],
        "max_circuits": 42
    },
    "commercial": {
        "columns": ["Circuit", "Load", "Breaker", "Phase"],
        "max_circuits": 84
    }
}

config = PANEL_CONFIG.get(panel_type, PANEL_CONFIG["residential"])
columns = config["columns"]
max_circuits = config["max_circuits"]
```

## When NOT to Deduplicate

Some duplication is acceptable:

- **Test code** - Tests should be explicit and readable
- **Configuration** - Each config may need independent changes
- **Version-specific code** - Different versions may diverge intentionally
- **Performance-critical sections** - Sometimes inline code is faster

## Code Review Checklist

Before submitting code, verify:

- [ ] Searched codebase for existing similar functionality
- [ ] No copy-pasted code blocks (extract if duplicated)
- [ ] Used parameters instead of creating function variants
- [ ] Considered creating utility function if logic is reusable
- [ ] Checked if base class can provide shared behavior

## Existing Reusable Components

Reference these before creating new ones:

| Component | Location | Provides |
|-----------|----------|----------|
| PDF processing | `PanelSearchToolV21.py` | PDF to image conversion |
| OCR reading | `BreakerTableAnalyzer12.py` | EasyOCR wrapper |
| Header/Footer detection | `AnchoringClasses/` | Boundary finding |
| Image preprocessing | Various | Common CV operations |

## Related Documentation

- [documentation-standards.mdc](mdc:.cursor/rules/core/documentation-standards.mdc) - Documentation requirements
- [python-code-quality.mdc](mdc:.cursor/rules/python-code-quality.mdc) - Python standards
- [project-structure.mdc](mdc:.cursor/rules/reference/project-structure.mdc) - File locations
