---
description: Coding standards - DRY principles, documentation, and proactive suggestions
globs: **/*.py
alwaysApply: true
---

# Coding Standards

## DRY Principles

### Before Writing New Code

1. **Search first** - Check for existing similar functionality
2. **Extract at 2+** - If you write similar code twice, consider extracting
3. **Extract at 3+** - If you write similar code three times, must extract
4. **Parameterize** - Use parameters instead of duplicating with minor changes

### Duplication Patterns to Avoid

```python
# ❌ Bad: Duplicate preprocessing
def process_panel_a(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    # ...

def process_panel_b(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    # ...

# ✅ Good: Extract common logic
def preprocess_image(image, blur_kernel=(5, 5)):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    return cv2.GaussianBlur(gray, blur_kernel, 0)
```

## Documentation Standards

### Function Docstrings (Google Style)

```python
def process_panel_image(image: np.ndarray, threshold: float = 0.5) -> dict:
    """Process a panel image and extract breaker information.
    
    Args:
        image: NumPy array in BGR format.
        threshold: Confidence threshold (0.0-1.0).
    
    Returns:
        Dictionary with detected breakers and positions.
    
    Raises:
        ValueError: If image is empty or threshold out of range.
    """
```

### When to Document

- New reusable functions → Add docstring
- Bug fixes → Update `context/known-issues.mdc`
- New patterns → Add to relevant context file

### When NOT to Document

- Self-explanatory code with clear names
- Standard library usage
- Trivial getters/setters
- Temporary DevEnv scripts

## Proactive Suggestions

### When to Suggest Alternatives

| Trigger | Action |
|---------|--------|
| Quick fix creates tech debt | Suggest proper solution |
| Performance implications | Mention better approach |
| Existing patterns violated | Point to established pattern |
| Security concerns | Flag the issue |

### Alternative Suggestion Format

```markdown
## Alternative Approach

**Your approach:** [description]
- Pros: [list]
- Cons: [list]

**Suggested alternative:** [description]
- Pros: [list]
- Cons: [list]

**Recommendation:** [clear recommendation with reasoning]
```

### When NOT to Suggest

- User explicitly wants specific approach
- Request is simple and straightforward
- Time is critical (production emergency)
- Alternative is only marginally better

## Python Style (PEP 8)

### Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Modules | `lowercase_underscores` | `page_filter.py` |
| Classes | `PascalCase` | `BreakerTableAnalyzer` |
| Functions | `lowercase_underscores` | `find_panel_headers()` |
| Constants | `UPPERCASE_UNDERSCORES` | `MAX_RETRY_COUNT` |
| Private | `_leading_underscore` | `_internal_method()` |

### Error Handling

```python
# ✅ Good: Specific exceptions with logging
try:
    doc = fitz.open(path)
except FileNotFoundError:
    logger.error(f"PDF not found: {path}")
    raise
except fitz.FileDataError as e:
    logger.error(f"Invalid PDF: {path} - {e}")
    raise ValueError(f"Cannot open PDF: {e}") from e

# ❌ Bad: Bare except, swallowing errors
try:
    doc = fitz.open(path)
except:
    return None
```

## Version File Naming

Files with version suffixes (e.g., `V21`, `V12`) indicate iteration history:

- **Always use highest version** for active development
- Check `uplink_server.py` imports for currently active versions
- Lower versions kept for reference/rollback

## Debug Code Cleanup

**ALWAYS remove debug instrumentation after debugging is complete:**

### What to Remove

- Debug log statements (file writes, print statements)
- `# #region agent log` / `# #endregion` blocks
- Temporary variables used only for logging
- Hardcoded debug file paths (e.g., `.cursor/debug.log`)

### Cleanup Checklist

After fixing a bug:

1. Search for `# #region agent log` in modified files
2. Search for `debug.log` or similar debug file references
3. Remove all temporary debug imports (`import json as _json`, etc.)
4. Verify code still works after cleanup
5. Delete any debug log files created during debugging

### Example

```python
# ❌ Bad: Debug code left in production
# #region agent log
import json as _json
with open("/path/debug.log", "a") as _f:
    _f.write(_json.dumps({"data": value}) + "\n")
# #endregion
result = process(value)

# ✅ Good: Clean production code
result = process(value)
```
