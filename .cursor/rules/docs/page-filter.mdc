---
description: Documentation for PageFilter - PDF page filtering for electrical sheets
globs: PageFilter/**/*
alwaysApply: false
---

# PageFilter Documentation

## File Location
- **Current**: `PageFilter/PageFilterV2.py`
- **Legacy**: `PageFilter/PageFilter.py`

## Purpose

Filters PDF pages to keep only electrical-related sheets:
- Detects E-sheets (E### naming convention)
- Filters out non-electrical pages (P=plumbing, M=mechanical, etc.)
- Uses OCR and footprint detection for classification

---

## Class: `PageFilter`

### Constructor Parameters

```python
PageFilter(
    output_dir: str,                    # Output directory for filtered PDF
    
    # Rendering
    dpi: int = 300,                     # Rasterization DPI
    longest_cap_px: int = 9000,         # Max dimension cap
    proc_scale: float = 0.5,            # Processing scale factor
    
    # OCR Settings
    use_ocr: bool = True,
    ocr_gpu: bool = False,
    ocr_zoom: float = 2.4,              # Zoom for corner OCR
    
    # Corner Crop (title block area)
    crop_frac: tuple = (0.88, 0.92, 0.98, 0.98),  # (left, top, right, bottom)
    label_tall_factor: float = 4.0,     # How much to extend crop upward
    crop_expand_right: float = 0.02,    # Extend crop rightward
    
    # Scoring Thresholds
    hard_hit_score: float = 6.5,        # Gold threshold (keep)
    min_hit_score: float = 3.0,         # Soft threshold
    
    # Scoring Weights
    w_strong: float = 4.5,              # Panel schedules, single-line
    w_riser: float = 3.5,               # Riser diagrams
    w_diag: float = 2.0,                # Generic diagrams
    w_base: float = 1.0,                # Generic schedules
    
    # Pattern Matching
    pattern_e_loose: str = r"^E[A-Z\-]{0,5}.*\d.*\d",
    pattern_non_e: str = r"^(?:P|M|C|A|F|S|X)[A-Z\-]{0,5}.*\d.*\d",
    
    # Footprint Detection (fallback)
    rect_w_fr_range: tuple = (0.10, 0.55),
    rect_h_fr_range: tuple = (0.10, 0.60),
    min_rectangularity: float = 0.70,
    min_rect_count: int = 2,
    
    # Output
    use_ghostscript_letter: bool = True,
    letter_orientation: str = "portrait",  # or "landscape"
    gs_use_cropbox: bool = True,
    gs_compat: str = "1.7",
    
    verbose: bool = True,
    debug: bool = False,
)
```

### Public API

#### `readPdf(pdf_path: str) -> tuple`

```python
kept, dropped, out_pdf, log_json = filter.readPdf("/path/to/input.pdf")

# Returns:
# - kept: List[int]      - 1-indexed page numbers kept
# - dropped: List[int]   - 1-indexed page numbers dropped
# - out_pdf: str         - Path to filtered PDF (or None if empty)
# - log_json: str        - Path to debug log JSON (if debug=True)
```

---

## Detection Algorithm

### Pass A: E-Sheet Detection (OCR)

```
For each page:
1. Crop corner region (title block)
   - Base: bottom-right corner (crop_frac)
   - Extended: up by label_tall_factor, right by crop_expand_right
   
2. OCR the crop
   - Use EasyOCR with allowlist: A-Z, 0-9, -, .
   
3. Normalize tokens:
   - Uppercase
   - O→0, I/L/|→1, S→5, B→8 (in numeric context)
   
4. Match patterns:
   - E-sheet: ^E[A-Z-]{0,5}.*\d.*\d (e.g., "E-101", "E2.01")
   - Non-E: ^[PMCAFSX][A-Z-]{0,5}.*\d.*\d (e.g., "P-101")
```

### Pass B: Label Scoring (for E-sheets)

```
For each E-sheet:
1. Reuse same OCR text from corner crop

2. Score against label buckets:
   - panel_schedules: "panel schedule", "panelboard schedule"
   - single_one_line: "single line", "one line", "1-line"
   - riser: "riser", "riser diagram"
   - diagram_generic: "diagram", "drawing", "schematic"
   - schedules_generic: "schedule"

3. Fuzzy matching (Levenshtein):
   - "schedule" with ≤2 edits
   - "panel" with ≤1 edit
   - "riser" with ≤1 edit

4. Priority:
   - Panel schedules pages first
   - Then generic schedules
   - Then other hits (single-line, riser, diagram)
   - Fallback: keep all E-sheets
```

### Fallback: Footprint Detection

```
When no E-sheets found:
1. Render page at DPI
2. Binarize ink (Otsu + morphology)
3. Find whitespace connected components
4. Detect "holes" (voids) that look rectangular:
   - Width: 10-55% of page
   - Height: 10-60% of page
   - Rectangularity ≥ 0.70
5. Need ≥2 qualifying footprints to keep page
```

---

## Label Pattern Buckets

```python
_label_patterns = {
    "panel_schedules": [
        r"\bpanel\s*schedules?\b",
        r"\bpanelboard\s*schedules?\b",
    ],
    "single_one_line": [
        r"\bsingle[\s\-]?line\b",
        r"\bone[\s\-]?line\b",
        r"\b1[\s\-]?line\b",
    ],
    "riser": [
        r"\briser\b",
        r"\briser\s*diagram\b",
    ],
    "diagram_generic": [
        r"\belectrical\s*diagram(s)?\b",
        r"\bdiagram(s)?\b",
        r"\bdrawing(s)?\b",
    ],
    "schedules_generic": [
        r"\bschedules?\b",
    ],
}
```

---

## Output Processing

### Ghostscript Letter Fitting

When `use_ghostscript_letter=True`:

```python
def _gs_fit_to_letter(self, in_pdf: str, out_pdf: str) -> str:
    """
    Uses Ghostscript to:
    - Fit pages to US Letter (612x792 pt or 792x612 for landscape)
    - Preserve vector graphics
    - Apply CropBox (if gs_use_cropbox=True)
    """
    args = [
        "gs", "-q", "-dBATCH", "-dNOPAUSE",
        "-sDEVICE=pdfwrite",
        "-dFIXEDMEDIA", "-dPDFFitPage",
        f"-dDEVICEWIDTHPOINTS={width}",
        f"-dDEVICEHEIGHTPOINTS={height}",
        # ...
    ]
```

---

## Debug Output

When `debug=True`:

```
filter_debug/
├── crops/
│   ├── page_001_tallcorner_x4.png    # Corner crops per page
│   ├── page_002_tallcorner_x4.png
│   └── ...
├── <basename>_filter_log.json        # Decision log
└── <basename>_raw.pdf                # Pre-GS filtered PDF
```

### Log JSON Format

```json
[
    {
        "page": 1,
        "decision": "KEEP",
        "reason": "panel schedules priority",
        "label_score": 9.0,
        "label_tags": ["panel_schedules"],
        "passA": {
            "page": 1,
            "corner_hits": [{"text": "E-101", "conf": 0.95}],
            "decision_passA": "E"
        }
    },
    {
        "page": 2,
        "decision": "DROP",
        "reason": "Not selected after label prioritization"
    }
]
```

---

## Usage Example

```python
from PageFilter.PageFilterV2 import PageFilter

pf = PageFilter(
    output_dir="/path/to/output",
    dpi=400,
    use_ocr=True,
    verbose=True,
    debug=True,
)

kept, dropped, filtered_pdf, log_json = pf.readPdf("/path/to/drawings.pdf")

print(f"Kept pages: {kept}")       # [1, 3, 5, 7]
print(f"Dropped: {dropped}")       # [2, 4, 6, 8, 9, 10]
print(f"Output: {filtered_pdf}")   # /path/to/output/drawings_electrical_filtered.pdf
```

---

## Integration with Pipeline

In `uplink_server.py`:

```python
def render_pdf_to_images(saved_pdf, img_dir, dpi=400):
    # 1. Filter pages
    pf = PageFilter(
        output_dir=str(img_dir.parent),
        dpi=400,
        use_ocr=True,
        verbose=True,
    )
    kept_pages, dropped_pages, filtered_pdf, log_json = pf.readPdf(str(saved_pdf))
    
    # 2. If filter kept pages, use filtered PDF for panel detection
    pdf_for_finder = filtered_pdf if len(kept_pages) > 0 else str(saved_pdf)
    
    # 3. Run PanelBoardSearch on result
    finder = PanelBoardSearch(output_dir=str(img_dir), dpi=dpi, ...)
    return finder.readPdf(pdf_for_finder)
```

---

## Tuning Guide

| Goal | Adjust |
|------|--------|
| Keep more E-sheets | Lower `hard_hit_score` |
| Stricter label matching | Increase `w_strong`, decrease fuzziness |
| More footprint fallbacks | Lower `min_rectangularity`, `min_rect_count` |
| Faster processing | Lower `dpi`, increase `proc_scale` |
| Better OCR accuracy | Increase `ocr_zoom`, enable `ocr_gpu` |

---

## Related Documentation

- [Application Overview](mdc:.cursor/rules/docs/application-overview.mdc) - High-level system architecture
- [Uplink Server](mdc:.cursor/rules/docs/uplink-server.mdc) - How page filter is called from the server
- [Panel Detection](mdc:.cursor/rules/docs/panel-detection.mdc) - Panel detection that runs after page filtering
- [Project Structure](mdc:.cursor/rules/reference/project-structure.mdc) - Complete file listing
