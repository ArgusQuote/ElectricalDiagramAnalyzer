from ._anvil_designer import uploadTemplate
from anvil import *
import anvil.server, anvil.users, json

USE_UI_OVERRIDES = True  # flip to True to send overrides

class upload(uploadTemplate):
  def __init__(self, **properties):
    self.init_components(**properties)
    if not anvil.users.get_user():
      open_form('login'); return

    self._job_name = None
    self._job_start_ts_ms = 0

    if hasattr(self, "go_btn"):
      self.go_btn.text = "Generate BOM"

    if hasattr(self, "instructions_btn"):
      self.instructions_btn.set_event_handler('click', self.instructions_btn_click)

    if hasattr(self, "enclosure_style_dd"):
      self.enclosure_style_dd.items = [
        ("NEMA 1 ‚Äî Flush", "NEMA1_FLUSH"),
        ("NEMA 1 ‚Äî Surface", "NEMA1_SURFACE"),
        ("NEMA 3R (Outdoor)", "NEMA3R"),
      ]
      self.enclosure_style_dd.selected_value = "NEMA1_FLUSH"

    if hasattr(self, "file_loader"):
      self.file_loader.accept = "application/pdf,.pdf"
      self.file_loader.set_event_handler('change', self.file_loader_change)

    if not hasattr(self, "result_panel"):
      self.result_panel = FlowPanel()
      self.add_component(self.result_panel)

    if not hasattr(self, "timer_1"):
      self.timer_1 = Timer()
      self.timer_1.interval = 0
      self.timer_1.set_event_handler('tick', self.timer_1_tick)
      self.add_component(self.timer_1)

    self._job_id = None
    self._node_id = None  # owner is always resolved server-side by email

  # --- make the job note string ---
  def _build_job_note(self, file_media):
    if hasattr(self, "text_box_1") and self.text_box_1.text:
      job_name = self.text_box_1.text.strip()
    else:
      fname = (getattr(file_media, "name", "") or "").strip()
      job_name = fname.rsplit(".", 1)[0] if fname else "untitled"

    job_name = job_name.replace("|", "/").replace("\n", " ").replace("\r", " ")
    if len(job_name) > 80:
      job_name = job_name[:80]
    self._job_name = job_name

    try:
      from anvil import js
      submitted_at_utc = js.window.Date().toISOString()
      submitted_local  = js.window.Date().toLocaleString()
      tz_offset_min    = int(js.window.Date().getTimezoneOffset())
    except Exception:
      from datetime import datetime
      submitted_at_utc = datetime.utcnow().isoformat() + "Z"
      submitted_local  = submitted_at_utc
      tz_offset_min    = 0

    user = anvil.users.get_user()
    user_email = ""
    if user:
      try:
        user_email = user['email'] or ""
      except Exception:
        pass

    return (
      f"job_name={job_name} | submitted_at_utc={submitted_at_utc} | "
      f"submitted_local={submitted_local} | tz_offset_min={tz_offset_min} | user={user_email}"
    )

  # --- helper: ensure uploaded file is a PDF ---
  def _is_pdf(self, media):
    if not media:
      return False
    ct = (getattr(media, "content_type", "") or "").lower()
    name = (getattr(media, "name", "") or "").lower()
    return ("pdf" in ct) or name.endswith(".pdf")

  def file_loader_change(self, file=None, **event_args):
    media = file or getattr(self.file_loader, "file", None)
    if not self._is_pdf(media):
      try:
        self.file_loader.file = None
      except Exception:
        pass
      Notification("PDFs only (.pdf).", style="warning").show()

  def build_ui_overrides(self):
    overrides = {"panelboards": {}, "transformers": {}, "disconnects": {}}
    if getattr(self, "check_box_1", None) and self.check_box_1.checked:
      overrides["panelboards"]["bussing_material"] = "COPPER"

    sel = getattr(self, "enclosure_style_dd", None)
    choice = sel.selected_value if sel else "NEMA1_FLUSH"
    if choice == "NEMA3R":
      overrides["panelboards"]["enclosure"] = "NEMA3R"
    elif choice == "NEMA1_SURFACE":
      overrides["panelboards"]["enclosure"] = "NEMA1"
      overrides["panelboards"]["default_trim_style"] = "SURFACE"
    else:
      overrides["panelboards"]["enclosure"] = "NEMA1"
      overrides["panelboards"]["default_trim_style"] = "FLUSH"

    if getattr(self, "check_box_4", None) and self.check_box_4.checked:
      overrides["panelboards"]["rating_type"] = "SERIES_RATED"
    if getattr(self, "check_box_5", None) and self.check_box_5.checked:
      overrides["panelboards"]["allow_plug_on_breakers"] = False
    if getattr(self, "check_box_6", None) and (not self.check_box_6.checked):
      overrides["panelboards"]["allow_square_d_spd"] = False
    if getattr(self, "check_box_10", None) and (not self.check_box_10.checked):
      overrides["disconnects"]["allow_littlefuse"] = False

    return {k: v for k, v in overrides.items() if v}

  def go_btn_click(self, **event_args):
    if not anvil.users.get_user():
      open_form('login'); return
  
    f = getattr(self.file_loader, "file", None)
    if not self._is_pdf(f):
      Notification("Please choose a PDF.", style="warning").show()
      return
  
    try:
      # Build the job name + note (same as before)
      job_note = self._build_job_note(f)
      ui_overrides = self.build_ui_overrides() if USE_UI_OVERRIDES else {}
  
      # Optional: stash job_name for the downstream form
      _ = self._job_name  # set by _build_job_note
  
      # Hand off to the dedicated full-screen processing form.
      # That form will:
      #   - Upload/submit asynchronously
      #   - Show progress and elapsed time
      #   - Poll until done
      #   - Navigate to output on completion
      open_form('processing', file=f, ui_overrides=ui_overrides, job_note=job_note, job_name=self._job_name)
  
    except Exception as e:
      msg = (getattr(e, "args", [""]) or [""])[0] or str(e) or type(e).__name__
      alert(f"‚ùå Failed to start job:\n{msg}")
  
  def timer_1_tick(self, **event_args):
    try:
      if not getattr(self, "_job_id", None):
        self.timer_1.interval = 0
        return
  
      status = anvil.server.call("get_job_status", self._job_id) or {}
      state = (status.get("state") or "unknown").lower()
      step  = status.get("step", "")
  
      # Update visible status line
      for c in self.result_panel.get_components():
        if isinstance(c, Label) and c.text.startswith("Status:"):
          c.text = f"Status: {state}{(' ¬∑ ' + step) if step else ''}"
          break
  
      # Soft-unknown from server when Uplink briefly drops ‚Üí quietly keep polling
      if state == "unknown" and (status.get("error") == "uplink_disconnected"):
        # gentle backoff (cap at 3s)
        try:
          cur = float(self.timer_1.interval or 1.0)
        except Exception:
          cur = 1.0
        self.timer_1.interval = min(3.0, cur + 0.5)
        return
  
      if state == "done":
        self.timer_1.interval = 0
        finished = status.get("result") or status
        self._render_finished(finished)
        self.go_btn.enabled = True
        self.go_btn.text = "Generate BOM"
        return
  
      if state == "error":
        self.timer_1.interval = 0
        alert(f"‚ùå Processing failed:\n{status.get('error','Unknown error')}")
        self.go_btn.enabled = True
        self.go_btn.text = "Generate BOM"
        return
  
      if state == "not_found":
        self.timer_1.interval = 0
        alert("Session mismatch or job not found.\nTry logging in again and resubmitting.",
              title="Owner mismatch")
        self.go_btn.enabled = True
        self.go_btn.text = "Generate BOM"
        return
  
      # queued / running / unknown ‚Üí keep polling
      return
  
    except Exception as e:
      # If the client itself sees an uplink drop in the exception text, treat as transient
      msg_type = str(type(e))
      msg = f"{type(e).__name__}: {e}"
      if "UplinkDisconnectedError" in msg_type or "Uplink disconnected" in str(e):
        try:
          cur = float(self.timer_1.interval or 1.0)
        except Exception:
          cur = 1.0
        self.timer_1.interval = min(3.0, cur + 0.5)
        return
  
      self.timer_1.interval = 0
      alert(f"Polling error:\n{msg}")
      self.go_btn.enabled = True
      self.go_btn.text = "Generate BOM"

  def _render_finished(self, resp: dict):
    open_form('output', result=resp, job_name=self._job_name)

    summary = (
      f"‚úÖ Saved PDF: {resp.get('saved_pdf','(n/a)')}\n"
      f"üìÇ Output: {resp.get('output_dir','(n/a)')}\n"
      f"üñºÔ∏è Images: {resp.get('image_count', len(resp.get('images', []) or []))}"
    )
    self.result_panel.add_component(Label(text=summary))

    comp_json = json.dumps(resp.get("component", {}) or {}, indent=2, default=str)
    self.result_panel.add_component(Label(text="Parsed Component:"))
    self.result_panel.add_component(TextArea(text=comp_json, height=200, width="100%"))

    rules_json = json.dumps(resp.get("rules_result", {}) or {}, indent=2, default=str)
    self.result_panel.add_component(Label(text="Rules Engine Output:"))
    self.result_panel.add_component(TextArea(text=rules_json, height=250, width="100%"))

    images = resp.get("images") or []
    if images:
      paths_preview = "\n".join(images[:5])
      self.result_panel.add_component(Label(text="First image paths (on VM):"))
      self.result_panel.add_component(TextArea(text=paths_preview, height=120, width="100%"))

  def logout_btn_click(self, **event_args):
    anvil.users.logout()
    Notification("Logged out", timeout=1.5).show()
    open_form('login')

  def instructions_btn_click(self, **event_args):
    open_form('instructions')